// lora_p2p_go_examples.go
// Two example approaches to send/receive LoRa packets in Go:
// 1) Using a UART-based LoRa module with AT-style commands (e.g., EBYTE E32 series).
//    This is the simplest to test and commonly used on Raspberry Pi via USB-serial or UART.
// 2) Using a Semtech SX127x radio via SPI (low-level). This example uses periph.io to access
//    SPI and GPIO. It's a minimal driver to TX/RX in LoRa mode — suitable as a starting point.

package main

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"time"
)

// ---------------------------
// Example A: UART (E32-like)
// ---------------------------
// Hardware: EBYTE E32 modules (or similar) which accept simple serial commands to send raw
// bytes over LoRa. If you have such a module connected to /dev/ttyS0 or USB-serial,
// this example shows how to send and receive.

// To run this example, you need to install: go get go.bug.st/serial.v1

// Usage: set the serial path and baud accordingly.

/* Example usage (pseudo AT-like):
   Many E32 modules accept the raw payload (in transparent mode) — you just write bytes.
   If in fixed mode, you may need to send an AT command to set destination address, etc.
*/

func serialExample(serialPath string, baud int) error {
	// open serial
	// import here to avoid unused import when not running this func
	_ = time.Second
	port, err := openSerial(serialPath, baud)
	if err != nil {
		return err
	}
	defer port.Close()

	// Start a goroutine to read incoming frames
	go func() {
		s := bufio.NewScanner(port)
		for s.Scan() {
			fmt.Printf("[RX] %s\n", s.Text())
		}
		if err := s.Err(); err != nil {
			log.Printf("serial read error: %v", err)
		}
	}()

	// Send a packet every 2 seconds
	for i := 0; i < 10; i++ {
		payload := fmt.Sprintf("Hello LoRa %d", i)
		_, err := port.Write([]byte(payload))
		if err != nil {
			return err
		}
		log.Printf("[TX] %s", payload)
		time.Sleep(2 * time.Second)
	}

	return nil
}

// openSerial is a tiny wrapper that opens a serial port using go.bug.st/serial
func openSerial(path string, baud int) (*os.File, error) {
	// For simplicity we use /dev/ttyUSB0 via os.OpenFile if available. In practice
	// you should use the serial lib (go.bug.st/serial.v1). This wrapper tries to
	// open the device as a file which works for many platforms but not Windows.
	f, err := os.OpenFile(path, os.O_RDWR|os.O_SYNC, 0666)
	if err != nil {
		return nil, fmt.Errorf("open serial %s: %w", path, err)
	}
	return f, nil
}

// ---------------------------
// Example B: SX127x via SPI (periph.io)
// ---------------------------
// Note: This is a minimal illustrative implementation. Real deployments need
// proper error handling, IRQ pin wiring (DIO0), and attention to reset and
// antenna switching (PA_BOOST). The code assumes you wire:
//  - NSS/CS to spidev chip select
//  - RESET to a GPIO you control
//  - DIO0 to a GPIO you can poll for RxDone/TxDone
//  - SPI bus available as /dev/spidevX.Y

// This SX127x minimal driver implements:
//  - set LoRa mode
//  - set frequency
//  - write payload to FIFO and start TX
//  - set RX continuous and read FIFO on RxDone

// To use periph.io: go get periph.io/x/periph

/* IMPORTANT: The SX127x register sequences are based on Semtech datasheet.
   This example is compact and omits many production details (CRC settings,
   implicit/explicit header, whitening, AGC...). Use as a starting point. */

// Below we provide a simplified SX127x TX path implemented by calling a small
// helper binary or by using spidev via os.File and ioctl; implementing raw SPI
// using os.File is platform dependent. For the sake of a single-file example
// that you can read & adapt quickly, we'll show pseudo-code / illustrative
// functions you should implement with periph.io in your environment.

// Because periph.io requires runtime init and hardware, the full runnable
// SPI code isn't executed here. Instead, include the driver skeleton.

// -------------------------------------------------
// SX127x register constants (subset)
// -------------------------------------------------
const (
	RegOpMode        = 0x01
	RegFrMsb         = 0x06
	RegFrMid         = 0x07
	RegFrLsb         = 0x08
	RegPaConfig      = 0x09
	RegLna           = 0x0c
	RegFifoAddrPtr   = 0x0d
	RegFifoTxBase    = 0x0e
	RegFifoRxBase    = 0x0f
	RegIrqFlags      = 0x12
	RegRxNbBytes     = 0x13
	RegPktRssiValue  = 0x1a
	RegRssiValue     = 0x1b
	RegModemConfig1  = 0x1d
	RegModemConfig2  = 0x1e
	RegPayloadLength = 0x22
	RegDioMapping1   = 0x40
	RegVersion       = 0x42
)

// Some opmode values
const (
	LongRangeMode = 0x80 // LoRa mode
	ModeSleep     = 0x00
	ModeStandby   = 0x01
	ModeTx        = 0x03
	ModeRxCont    = 0x05
)

// helper: freq to register
func freqToReg(freqHz int) (msb, mid, lsb byte) {
	// Frequency register = freqHz / (32e6 / (1 << 19))
	// Reg value = freqHz * (2^19 / 32e6)
	frf := uint32((uint64(freqHz) << 19) / 32000000)
	msb = byte((frf >> 16) & 0xff)
	mid = byte((frf >> 8) & 0xff)
	lsb = byte(frf & 0xff)
	return
}

// Pseudo low-level SPI read/write. Replace with periph.io SPI in real code.
func sxWriteReg(spi *os.File, reg byte, val byte) error {
	// SPI write: address MSB = 1 for write? SX127x expects address with MSB=1 for write
	// (datasheet: MSB = 1 for write). So send [addr | 0x80, val]
	b := []byte{reg | 0x80, val}
	_, err := spi.Write(b)
	return err
}

func sxReadReg(spi *os.File, reg byte) (byte, error) {
	// SPI read: send address with MSB=0, then read one byte
	b := []byte{reg & 0x7f, 0x00}
	_, err := spi.Write(b)
	if err != nil {
		return 0, err
	}
	// read response (platform dependent). For many spidev writes above will clock out reply
	resp := make([]byte, 2)
	_, err = spi.Read(resp)
	if err != nil {
		return 0, err
	}
	return resp[1], nil
}

// Minimal TX flow (illustrative):
func sx127xTxExample(spiDev string, freqHz int, payload []byte) error {
	// open spidev
	f, err := os.OpenFile(spiDev, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("open spi %s: %w", spiDev, err)
	}
	defer f.Close()

	// 1) Put in sleep then LoRa mode
	err = sxWriteReg(f, RegOpMode, ModeSleep|LongRangeMode)
	if err != nil {
		return err
	}
	// small delay
	time.Sleep(10 * time.Millisecond)

	// 2) Set frequency
	msb, mid, lsb := freqToReg(freqHz)
	sxWriteReg(f, RegFrMsb, msb)
	sxWriteReg(f, RegFrMid, mid)
	sxWriteReg(f, RegFrLsb, lsb)

	// 3) Configure FIFO
	sxWriteReg(f, RegFifoTxBase, 0x00)
	sxWriteReg(f, RegFifoAddrPtr, 0x00)

	// 4) modem config (SF7BW125, CR4/5) - these values are illustrative
	sxWriteReg(f, RegModemConfig1, 0x72) // BW=125kHz, CR=4/5, implicit header off
	sxWriteReg(f, RegModemConfig2, 0x74) // SF=7, CRC on

	// 5) write payload to FIFO
	// write FIFO register repeatedly
	for _, b := range payload {
		sxWriteReg(f, 0x00, b) // FIFO address 0x00 for write
	}
	sxWriteReg(f, RegPayloadLength, byte(len(payload)))

	// 6) start TX
	sxWriteReg(f, RegOpMode, ModeTx|LongRangeMode)

	// 7) wait for TxDone (poll IRQ flags)
	for {
		v, _ := sxReadReg(f, RegIrqFlags)
		if v&0x08 != 0 { // TxDone flag
			// clear flags
			sxWriteReg(f, RegIrqFlags, 0xff)
			break
		}
		time.Sleep(5 * time.Millisecond)
	}

	log.Printf("SX127x TX done, payload len=%d", len(payload))
	return nil
}

// Minimal RX flow: set RX continuous and poll DIO0 or check IRQ
func sx127xRxExample(spiDev string, freqHz int, timeout time.Duration) error {
	f, err := os.OpenFile(spiDev, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("open spi %s: %w", spiDev, err)
	}
	defer f.Close()

	// set LoRa mode + frequency (same as Tx setup)
	sxWriteReg(f, RegOpMode, ModeSleep|LongRangeMode)
	msb, mid, lsb := freqToReg(freqHz)
	sxWriteReg(f, RegFrMsb, msb)
	sxWriteReg(f, RegFrMid, mid)
	sxWriteReg(f, RegFrLsb, lsb)

	// set fifo rx base
	sxWriteReg(f, RegFifoRxBase, 0x00)
	sxWriteReg(f, RegFifoAddrPtr, 0x00)

	// modem config set as in TX
	sxWriteReg(f, RegModemConfig1, 0x72)
	sxWriteReg(f, RegModemConfig2, 0x74)

	// set Rx continuous
	sxWriteReg(f, RegOpMode, ModeRxCont|LongRangeMode)

	start := time.Now()
	for time.Since(start) < timeout {
		v, _ := sxReadReg(f, RegIrqFlags)
		if v&0x40 != 0 { // RxDone
			// read number of bytes
			rxnb, _ := sxReadReg(f, RegRxNbBytes)
			// set fifo addr pointer to current rx
			// read FIFO
			pkt := make([]byte, rxnbToInt(rxnb))
			for i := 0; i < len(pkt); i++ {
				b, _ := sxReadReg(f, 0x00) // FIFO
				pkt[i] = b
			}
			log.Printf("[RX] %s", hex.EncodeToString(pkt))
			// clear flags
			sxWriteReg(f, RegIrqFlags, 0xff)
			return nil
		}
		time.Sleep(10 * time.Millisecond)
	}
	return fmt.Errorf("rx timeout")
}

func rxnbToInt(b byte) int { return int(b) }

// ---------------------------
// main: example runner
// ---------------------------
func main() {
	fmt.Println("LoRa P2P examples in Go — choose which to run by editing main")

	// Example: UART E32 style (adjust path if using real serial)
	go func() {
		err := serialExample("/dev/ttyUSB0", 9600)
		if err != nil {
			log.Printf("serial example err: %v", err)
		}
	}()

	// Example: SX127x TX of string "Hello"
	// NOTE: adjust spi device path and make sure you have permissions.
	payload := []byte("HelloLoRa")
	err := sx127xTxExample("/dev/spidev0.0", 868000000, payload)
	if err != nil {
		log.Printf("sx127x tx err: %v", err)
	}

	// Example: SX127x RX for 10s
	err = sx127xRxExample("/dev/spidev0.0", 868000000, 10*time.Second)
	if err != nil {
		log.Printf("sx127x rx err: %v", err)
	}

	select {}
}
